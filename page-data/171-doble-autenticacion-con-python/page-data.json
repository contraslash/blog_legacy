{"componentChunkName":"component---src-templates-blog-post-js","path":"/171-doble-autenticacion-con-python/","result":{"data":{"site":{"siteMetadata":{"title":"Blog de Contraslash (Legacy)"}},"markdownRemark":{"id":"bfe5987e-13a0-5a43-9b0d-9663ac9f2588","excerpt":"Doble autenticación con python Debo confesar varias cosas cosas: A pesar que me migré a Linode, aún conservo algunos servicios en Digital Ocean, solo porque me…","html":"<h1>Doble autenticación con python</h1>\n<p>Debo confesar varias cosas cosas:</p>\n<ol>\n<li>A pesar que me migré a Linode, aún conservo algunos servicios en Digital Ocean, solo porque me ha dado pereza terminar de migrarlos.</li>\n<li>Me llamó mucho la atención que DO implementara un segundo facor de autenticación con <a href=\"https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2\">Google Authenticator</a>.</li>\n<li>Siempre me han fascinado los tokens, si, ese pequeño dispositivo que muestra 6 números.</li>\n</ol>\n<p>La seguridad es un factor importante para todos y como buena práctica en todos los manuales de seguridad, se recomienda tener un segundo factor de autenticación, así que por qué no implementar uno con python?</p>\n<p>Existen un montón de referencias sobre cómo funcionan los Tokens, o mejor conocidos como Algoritmos de Contraseña única basados en HMAC (HMAC-Based One-Time Password Algorithm), y su implementación según el <a href=\"https://tools.ietf.org/html/rfc4226\">RFC4226</a> o Algoritmos de Contraseña única basados en el tiempo (Time-Based One-Time Password Algorithm), especificados en <a href=\"https://tools.ietf.org/html/rfc6238\">RFC6238</a>. Por simplicidad abreviados como HOTP y TOTP. </p>\n<p>Los algoritmos son relativamente sencillos de implementar, pero para no reinventar la rueda, tomé la opción fácil e instalé <a href=\"https://github.com/pyotp/pyotp\">pyotp</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pip install pyotp</code></pre></div>\n<p>El uso de esta librería es tan fácil que da risa. Tan solo necesitamos nuestra  semilla (seed) en base 32, (la cual sospechosamente se parecerá a mi SECRET_KEY de mis proyectos en django) y luego preguntar por los números actuales.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import pyotp\nimport base64\nSECRET_KEY = &quot;a-z8a(^+jtp$m6bp6&quot;57-uuv441=uc45%@q82flay%t#wv)s$41&quot;\nSECRET_KEY_BASE_32 = base64..b32encode(SECRET_KEY.encode()).decode()\ntotp = pyotp.TOTP(SECRET_KEY_BASE_32)</code></pre></div>\n<p>Después de jugar un poco con cadenas caracteres y cadenas de bytes podemos fácilmente preguntar por nuestra secuencia de 6 dígitos usando</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">totp.now()</code></pre></div>\n<p>Con esto nuestro servidor sabrá cual es el valor de la contraseña en cada momento del tiempo, solamente falta usar el mismo generador en un cliente para que nuestro usuario lo use.</p>\n<p>Para esto, debemos entender un poco la implementación de Google Authenticator, que será el cliente escogido para esta labor.</p>\n<p>Google Authenticator usa un formato URI para definir las claves, el cual está especificado en <a href=\"https://github.com/google/google-authenticator/wiki/Key-Uri-Format\">esta página</a>. Brevemente el formato que debemos usar debe cumplir con la siguiente estructura:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">otpauth://totp/&lt;Nombre del sitio&gt;:&lt;cuenta que se autentica&gt;?secret=&lt;Llave en base 32&gt;&amp;issuer=&lt;cuenta que se autentica&gt;</code></pre></div>\n<p>O, para nosotros los mortales que seguimos este ejemplo</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">otpauth://totp/contraslash.com:ma0?secret=MEWXUODBFBPCW2TUOASG2NTCOA3DKNZNOV2XMNBUGE6XKYZUGUSUA4JYGJTGYYLZEV2CG53WFFZSINBR&amp;issuer=ma0</code></pre></div>\n<p>Lo siguiente será generar un código QR, por fortuna, existe un módulo en python llamado <a href=\"https://pypi.python.org/pypi/qrcode\">qrcode</a> que hace el trabajo sucio por nosotros.</p>\n<blockquote>\n<p>Requerimos pillow que no se instala automáticamente como dependencia</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pip install pillow\npip install qrcode</code></pre></div>\n<p>Para generar nuestro código QR ejecutamos el siguiente comando</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">qr &quot;otpauth://totp/contraslash.com:ma0?secret=MEWXUODBFBPCW2TUOASG2NTCOA3DKNZNOV2XMNBUGE6XKYZUGUSUA4JYGJTGYYLZEV2CG53WFFZSINBR&amp;issuer=ma0&quot; &gt; qr.png</code></pre></div>\n<p>Y ya tendremos nuestr código qr listo para ser leido por nuestro Google Authenticator</p>","frontmatter":{"title":"Doble autenticación con python","date":"May 26, 2017","description":"Implementar un segundo Factor de Autenticación con Python y Google Authenticator"}}},"pageContext":{"slug":"/171-doble-autenticacion-con-python/","previous":{"fields":{"slug":"/170-recursos-importantes-sobre-devops/"},"frontmatter":{"title":"Recursos importantes sobre DevOps"}},"next":{"fields":{"slug":"/172-instalando-un-sistema-de-ficheros-compartidos-con/"},"frontmatter":{"title":"Instalando un sistema de ficheros compartidos con GlusterFS en Ubuntu"}}}}}